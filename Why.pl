%% Grammar for generating WhyML language goals from abstract syntax
%% Harry Stern, 2017, for ASHLEy
%% Supervised by Oliver Ray

header("(* This file has been generated by Why.pl to be used in Alt-Ergo *)\n\n").




% Write list of goals to a .why file
write_goals(File,Goals) :- open(File,write,Stream), header(H), write(Stream,H), N is 0, write_goals_stream(Stream,Goals,N).

%% Recurisively write numbered goals to file
write_goals_stream(Stream,[],_) :- close(Stream).
% goals are either in form [goal,...] or [wp,...]
% only prove goal types
write_goals_stream(Stream,[[wp,Wp,S,Q]|Tail],N) :- write_goals_stream(Stream,Tail,N).
write_goals_stream(Stream,[[message,M]|Tail],N) :- write_goals_stream(Stream,Tail,N).
write_goals_stream(Stream,[Goal|Tail],N) :-
	Goal = [goal,_,_,_,_],
	phrase(goal(Goal,N),C), atom_codes(G,C), write(Stream,G),!,
	N1 is N+1, write_goals_stream(Stream,Tail,N1).



%% A goal takes the form of
%% [*goaltype*, predicate1, predicate2, *prettyprintedversion of 
%% goal*]
%% Types are: skip, subst, while, strengthen, weaken


% Given a goal and goal number, the following grammar generates an .why representation of the goal
	goal(Goal,N) --> "goal g", {atom_codes(N,C)}, C, ":\n", goal(Goal).
	goal([goal,Type,P1,P2,Text]) -->
			"(* GOAL: {type:", goalType(Type),", text:\"", Text, "\"} *)\n\t",
			{variables(int,P1,Vi1), variables(int,P2,Vi2), union(Vi1,Vi2,Vi),
			variables(array,P1,Va1), variables(array,P2,Va2), union(Va1,Va2,Va)},

			forall(int,Vi), ({Va=[]}, "\t" | forall(array,Va) ),
			whyB(P1), goalAim(Type), whyB(P2), "\n\n".



	% 'forall' rule generates the line forall variables of some type
	forall(_,[]) --> {!}, "".
	forall(int,V) --> "forall ", variableList(V), ":int.\n\t".
	forall(array,V) --> "forall ", variableList(V), ":int farray.\n\t\t".

	variableList([V]) --> {atom_codes(V,C)},C.
	variableList([V|Rest]) --> {atom_codes(V,C)}, C, ",", variableList(Rest).


	goalType(skip) --> "skip".
	goalType(arraysubst) --> "arraysubst".
	goalType(subst) --> "subst".
	goalType(while) --> "while".
	goalType(strengthen) --> "strengthen".
	goalType(weaken) --> "weaken".

	goalAim(skip) --> equiv.
	goalAim(arraysubst) --> equiv.
	goalAim(subst) --> equiv.
	goalAim(while) --> equiv.
	goalAim(strengthen) --> implies.
	goalAim(weaken) --> implies.

	equiv --> " <-> ".
	implies --> " -> ".










% The grammar below takes a boolean statement in abstract syntax
% and generates its equivalent in WhyML language

whyB(true)			--> " true ".
whyB(false)		 	--> " false ".
whyB(not(B)) 		--> "( not ", "(", whyB(B), ") )".
whyB(and(B1,B2)) 	--> "( (",whyB(B1), ") and (", whyB(B2), ") )".
whyB(or(B1,B2)) 	--> "( (",whyB(B1), ") or (", whyB(B2), ") )".


whyB(forall([],B)) --> whyB(B).
whyB(forall([X|V],B)) --> "( forall ", {atom_codes(X,C)}, C, ": int. (", C, ">=0 -> ", whyB(forall(V,B)), "))".
whyB(exists([],B)) --> whyB(B).
whyB(exists([X|V],B)) --> "( exists ", {atom_codes(X,C)}, C, ": int. (", C, ">=0 -> ", whyB(forall(V,B)), "))".
%% whyB(forall(X,B)) 	--> "( forall ", {atom_codes(X,C)}, C, ": int. (" , C, ">=0 ->", whyB(B), "))".

whyB(implies(B1,B2))--> "(",whyB(B1), " -> ", whyB(B2), ")".
whyB(eq(E1,E2)) 	--> "(", whyA(E1), "=", whyA(E2), ")".
whyB(geq(E1,E2))	--> "(", whyA(E1), ">=", whyA(E2), ")".
whyB(leq(E1,E2))	--> "(", whyA(E1), "<=", whyA(E2), ")".
whyB(ge(E1,E2)) 	--> "(", whyA(E1), ">", whyA(E2), ")".
whyB(le(E1,E2)) 	--> "(", whyA(E1), "<", whyA(E2), ")".

whyB(array(X,L)) --> "(* Need to work out how to put to goal *)".


whyA(number(N)) --> {atom_codes(N,C)}, C.
whyA(variable(X)) --> {atom_codes(X,C)}, C.
whyA(elem(X,I)) --> {atom_codes(X,C)}, C,"[",whyA(I), "]".
whyA(add(E1,E2)) --> "(", whyA(E1), "+", whyA(E2), ")".
whyA(sub(E1,E2)) --> "(", whyA(E1), "-", whyA(E2), ")".
whyA(mul(E1,E2)) --> "(", whyA(E1), "*", whyA(E2), ")".
